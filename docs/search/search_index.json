{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Race On \u2013 USC Self-Driving Car Competition \u00b6 Announcements \u00b6 Control Workshop & Practice Session \u2013 Sunday, Feb. 23, 10am - 4pm (EEB 132) See Gain scheduling workshop for details. Challenge Overview \u00b6 The goal of this competition is to engage students in hardware-software development of a self-driving car for racing. Teams of 2 to 4 students compete to build the fastest car and have one semester to prepare for the two races, when all cars, turn by turn, race to record the fastest time. The competition is for USC Viterbi masters students and undergraduate juniors and seniors, regardless of Viterbi program or year. Sophomore undergraduate students are also welcome; however, the difficulty of this competition may be more appropriate for more experienced students. Students are not expected to have prior experience with self-driving cars. Teams will receive instructions how to assemble a car from scratch and program the control algorithm of a self-driving car. All cars are built on the same platform and race against each other on the same track configurations, thus innovation and creativity is what counts. To help the teams get started, a series of workshops on embedded hardware and software concepts will be organized to provide technical support to the students especially during the initial phase of the race. In addition, optional weekly sessions are to be held where teams can work on their projects and interact with other teams. Though these workshops are meant to help the teams develop their car, outside work on the project will be necessary, since an exceptional car will require thoughtful optimization to excel. With these workshops as a starting place, teams are given the unique opportunity to apply their technical knowledge and creative abilities to a real-world situation. Fees and Prizes \u00b6 For new teams, the fee to participate in Race On is $250 per team . This fee covers all the materials needed to assemble a self-driving car, such as the car kit, raspberry pi plus other components and accessories. Teams can get $100 back along with additional sensors and components by actively participating in races. Winning teams even stand a chance to win up to $400 . See Rules section for details. Car Kit \u00b6 Upon registration, new teams will receive their car, described below. Teams with returning members will use their previous car. The car is built around a 1/10 scale RC touring chassis powered by a brushed motor and a 2\u2013cell LiPo battery. The Raspberry Pi microprocessor through image processing will detect the track from the images supplied by a camera and adjust the steering angle and the motor speed to keep the car on the track. The images below show the assembled car, the camera and the Raspberry Pi board that when assemble form the car to be raced. The chassis, battery and the motor are regulated to ensure that no team gains an advantage through better components, and that creativity and superior programming differentiate the teams. Modifications of the chassis are allowed as long as the changes follow the competition rules. Moreover, more sensors can be added as long as the camera remains the main sensor used for steering the car. Cars are permitted to have a wireless connection with a computer for development and calibration, however, during the final race the car should operate autonomously and no external connection is permitted. All cars will be inspected before the final race and only the ones which comply with the above rules will be allowed to compete.","title":"Home"},{"location":"#race-on-usc-self-driving-car-competition","text":"","title":"Race On \u2013 USC Self-Driving Car Competition"},{"location":"#announcements","text":"Control Workshop & Practice Session \u2013 Sunday, Feb. 23, 10am - 4pm (EEB 132) See Gain scheduling workshop for details.","title":"Announcements"},{"location":"#challenge-overview","text":"The goal of this competition is to engage students in hardware-software development of a self-driving car for racing. Teams of 2 to 4 students compete to build the fastest car and have one semester to prepare for the two races, when all cars, turn by turn, race to record the fastest time. The competition is for USC Viterbi masters students and undergraduate juniors and seniors, regardless of Viterbi program or year. Sophomore undergraduate students are also welcome; however, the difficulty of this competition may be more appropriate for more experienced students. Students are not expected to have prior experience with self-driving cars. Teams will receive instructions how to assemble a car from scratch and program the control algorithm of a self-driving car. All cars are built on the same platform and race against each other on the same track configurations, thus innovation and creativity is what counts. To help the teams get started, a series of workshops on embedded hardware and software concepts will be organized to provide technical support to the students especially during the initial phase of the race. In addition, optional weekly sessions are to be held where teams can work on their projects and interact with other teams. Though these workshops are meant to help the teams develop their car, outside work on the project will be necessary, since an exceptional car will require thoughtful optimization to excel. With these workshops as a starting place, teams are given the unique opportunity to apply their technical knowledge and creative abilities to a real-world situation.","title":"Challenge Overview"},{"location":"#fees-and-prizes","text":"For new teams, the fee to participate in Race On is $250 per team . This fee covers all the materials needed to assemble a self-driving car, such as the car kit, raspberry pi plus other components and accessories. Teams can get $100 back along with additional sensors and components by actively participating in races. Winning teams even stand a chance to win up to $400 . See Rules section for details.","title":"Fees and Prizes"},{"location":"#car-kit","text":"Upon registration, new teams will receive their car, described below. Teams with returning members will use their previous car. The car is built around a 1/10 scale RC touring chassis powered by a brushed motor and a 2\u2013cell LiPo battery. The Raspberry Pi microprocessor through image processing will detect the track from the images supplied by a camera and adjust the steering angle and the motor speed to keep the car on the track. The images below show the assembled car, the camera and the Raspberry Pi board that when assemble form the car to be raced. The chassis, battery and the motor are regulated to ensure that no team gains an advantage through better components, and that creativity and superior programming differentiate the teams. Modifications of the chassis are allowed as long as the changes follow the competition rules. Moreover, more sensors can be added as long as the camera remains the main sensor used for steering the car. Cars are permitted to have a wireless connection with a computer for development and calibration, however, during the final race the car should operate autonomously and no external connection is permitted. All cars will be inspected before the final race and only the ones which comply with the above rules will be allowed to compete.","title":"Car Kit"},{"location":"registration/","text":"Spring 2020 Registration \u00b6 Thank you for your interest; however, the Race On Spring 2020 Registration is now closed :( To be kept in the loop regarding the current Spring 2020 Race On event as well as information on the upcoming Race On Fall 2020 registration , please subscribe to our newsletter (link found on the right).","title":"Registration"},{"location":"registration/#spring-2020-registration","text":"Thank you for your interest; however, the Race On Spring 2020 Registration is now closed :( To be kept in the loop regarding the current Spring 2020 Race On event as well as information on the upcoming Race On Fall 2020 registration , please subscribe to our newsletter (link found on the right).","title":"Spring 2020 Registration"},{"location":"rules/","text":"Rules \u2013 Spring 2020 \u00b6 Registration \u00b6 Registration for the Spring 2020 edition is open until Sunday, January 19 . Teams that register must pay $250 materials fee if all members are new to Race On. Teams where one or more team members competed in a previous Race On competition still have to register online but do not pay the materials fee. We encourage teams to reuse previously received cars and we can help replace certain components. Teams are formed of two to four students that are currently enrolled at USC and are the only ones who build, program, and race the car. Each team delegates a contact person that will represent the team. All teams compete in the same races and on the same racing track irrespective of their program and year of study. Students are required to exhibit appropriate sportsmanship behavior and any attempts of cheating would result in penalties or disqualification. Races \u00b6 Race On competition consists of three races with mandatory participation. Date Room Race 0 Saturday, February 8 EEB 132 Race 1 Saturday, February 29 EEB 132 Race 2 Friday, April 17 EEB 132 Teams are awarded points based on their performance in each race. In Race 0, teams will race on a simple loop track. The goal of this race is to stimulate teams to finish assembling their cars. In Race 1, teams will race on an average complexity track and will be awarded points for both participation and ranking. In Race 2 teams will race on a longer and more complex track. Teams will receive points for completing a lap and the ranking points will be double compared to the first race. Points \u00b6 Note The point system is designed such that a team that did average in Race 1 can still win the competition if they improve for Race 2. The best team from Race 1 does not automatically win if they do average in Race 2. However, winning Race 1 helps break some ties in the final standings. In all three races, teams will be awarded points for running the car, finishing a lap, and ranking in the top five in each race. Race 0 Race 1 Race 2 Run 2 2 - Lap - 2 4 Rank 1 - 10 20 Rank 2 - 8 16 Rank 3 - 6 12 Rank 4 - 4 8 Rank 5 - 2 4 Run points will be awarded in Race 0 and Race 1. Teams that manage to run their car, car moves autonomously on the track, will receive 2 points. Lap points will be awarded in Race 1 and Race 2. Teams that complete a lap would receive 2 points in Race 1 and 4 points in Race 2. Ranking points will be awarded in Race 1 and Race 2. The top five teams that have the fastest time will be awarded ranking points based on the table below. The ranking points of Race 2 are double of the ones from Race 1. The team score is the sum of the points accumulated in all the races. This final score will be compared against the final score of all the teams to determine the final ranking. The team with the most points wins. If multiple teams have the same number of points, they will receive the same ranking. Example Team 1 manages to assemble the car for Race 0 and run it on the track. In Race 1, the team runs the car but does not complete a lap, and in Race 2, the team finishes the lap and it is the fastest lap of all teams. As a result, Team 1 will receive 28 points: 2 points for running the car in Race 0, plus 2 points for running the car in Race 1, plus 4 points for finishing a lap in Race 2, and 20 points for ranking first in Race 2. Team 2 does not manage to assemble the car for Race 0. In Race 1 they finish a lap and rank third and in Race 2 the car runs on the track but does not complete a lap. As a result, team 2 will receive 10 points: 2 points for running the car in Race 1, plus 2 points for finishing a lap in Race 1, and 6 points for ranking third in Race 1. Awards \u00b6 Teams that competed before in Race On are allowed to switch to Jetson Nano once they earn 2 or more points. Teams that accumulate 4 points or more by the end of Race 1 will receive encoders and an inertial measurement unit as an award. At the end of the competition, after Race 2, teams will be awarded an Amazon gift card in the value of $10 for each accumulated point. Car Kit \u00b6 All teams compete with a car built around a 1/10 scale RC touring chassis. Distance between the front and back wheels, wheelbase, should be between 250 mm to 270 mm. Altering the contact surface of the tires is not allowed. Changing the tires to similar ones but with a different pattern is allowed. Cars should use one Mabuchi RS-540SH brushed motor to drive the car. Cars should use one battery, two LiPo cells with 7.4 V nominal and 8.4 V max, to power the car and the electronics. Converters that produce voltages above 8.4 V are not allowed. Cars should be controlled solely by a Raspberry Pi or Jetson Nano board and operate autonomously during the race. The camera must be the primary navigation sensor. Car dimensions should not exceed 12 inch width, 15 inch length, and 12 inch height with all sensors and additional boards mounted. Adding additional sensors such as accelerometer, gyroscope, encoders are allowed. Adjusting the suspension springs and weight balance, removing auxiliary chassis parts, and mounting additional boards is allowed. Additional modifications are allowed if they are easy to replicate by other teams. Attention To see whether your additional modifications are acceptable, contact Race On team before implementing them. If your modifications are illegal, you will not be allowed to compete in the races. Track \u00b6 The racing track is built out of black segments containing white lines for delimiting the track boundary. The dimensions of a track segment are 48 inch width and 48 inch length. The white lines delimiting the track are 2 inches wide and spaced 2 inches from the edge of the track segment. Track segments are of three types, Start/Finish Line, Straight Line, and 90\u00b0 Turn. The Start/Finish segment is similar to the Straight Line segment but has two white squares in the middle which are 2 inches wide and spaced 2 inches apart. Racing Day \u00b6 The racing day is composed of three parts, practice session in the morning followed by the car inspection around noon and ending with the race itself in the afternoon. The exact time of each part would be announced a week before the race day. Practice \u00b6 On the morning of the race day, each team will receive dedicate practice time on the race track. The start time and the duration of the practice session will be announced a week before. During the practice session, each time will receive 1 minute on the track and no other cars are allowed to be on the track during that time. At the end of the 1-minute practice run, teams are allowed to get back in line to request and additional minute. Inspection \u00b6 Before the race starts, all cars should be handed on for inspection. The judges will inspect the cars according to requirements specified in the cars section. Violation of the requirements would be penalized with extra time or disqualified based on the severity of the violation. Cars would stay in the inspection area until the beginning of the race. No mechanical modifications are allowed after this point without approval from the judges. Racing \u00b6 Only teams that passed the inspection are allowed to race. Teams will be grouped into 30 minutes slots. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams are allocated into slots at random and find their racing order within the slot at the beginning of that slot. The team has 4 minutes in the pre-race area to set up their car and practice on a simple oval track. The team that is going to race next has priority on the practice track. After being called for racing, teams have 4 minutes to record a time. Teams have a practice run plus three attempts to finish the race and record the fastest time. The first run is considered a practice run and does not count for ranking. Teams, in order, will finish the first attempt before proceeding with the second and then the third. Cars are placed two to six feet before the finish line. During the race, cars should always be between the two white lines delimiting the track. If during the race one or more wheels completely cross the white line, the attempt is marked as failed.","title":"Rules"},{"location":"rules/#rules-spring-2020","text":"","title":"Rules \u2013 Spring 2020"},{"location":"rules/#registration","text":"Registration for the Spring 2020 edition is open until Sunday, January 19 . Teams that register must pay $250 materials fee if all members are new to Race On. Teams where one or more team members competed in a previous Race On competition still have to register online but do not pay the materials fee. We encourage teams to reuse previously received cars and we can help replace certain components. Teams are formed of two to four students that are currently enrolled at USC and are the only ones who build, program, and race the car. Each team delegates a contact person that will represent the team. All teams compete in the same races and on the same racing track irrespective of their program and year of study. Students are required to exhibit appropriate sportsmanship behavior and any attempts of cheating would result in penalties or disqualification.","title":"Registration"},{"location":"rules/#races","text":"Race On competition consists of three races with mandatory participation. Date Room Race 0 Saturday, February 8 EEB 132 Race 1 Saturday, February 29 EEB 132 Race 2 Friday, April 17 EEB 132 Teams are awarded points based on their performance in each race. In Race 0, teams will race on a simple loop track. The goal of this race is to stimulate teams to finish assembling their cars. In Race 1, teams will race on an average complexity track and will be awarded points for both participation and ranking. In Race 2 teams will race on a longer and more complex track. Teams will receive points for completing a lap and the ranking points will be double compared to the first race.","title":"Races"},{"location":"rules/#points","text":"Note The point system is designed such that a team that did average in Race 1 can still win the competition if they improve for Race 2. The best team from Race 1 does not automatically win if they do average in Race 2. However, winning Race 1 helps break some ties in the final standings. In all three races, teams will be awarded points for running the car, finishing a lap, and ranking in the top five in each race. Race 0 Race 1 Race 2 Run 2 2 - Lap - 2 4 Rank 1 - 10 20 Rank 2 - 8 16 Rank 3 - 6 12 Rank 4 - 4 8 Rank 5 - 2 4 Run points will be awarded in Race 0 and Race 1. Teams that manage to run their car, car moves autonomously on the track, will receive 2 points. Lap points will be awarded in Race 1 and Race 2. Teams that complete a lap would receive 2 points in Race 1 and 4 points in Race 2. Ranking points will be awarded in Race 1 and Race 2. The top five teams that have the fastest time will be awarded ranking points based on the table below. The ranking points of Race 2 are double of the ones from Race 1. The team score is the sum of the points accumulated in all the races. This final score will be compared against the final score of all the teams to determine the final ranking. The team with the most points wins. If multiple teams have the same number of points, they will receive the same ranking. Example Team 1 manages to assemble the car for Race 0 and run it on the track. In Race 1, the team runs the car but does not complete a lap, and in Race 2, the team finishes the lap and it is the fastest lap of all teams. As a result, Team 1 will receive 28 points: 2 points for running the car in Race 0, plus 2 points for running the car in Race 1, plus 4 points for finishing a lap in Race 2, and 20 points for ranking first in Race 2. Team 2 does not manage to assemble the car for Race 0. In Race 1 they finish a lap and rank third and in Race 2 the car runs on the track but does not complete a lap. As a result, team 2 will receive 10 points: 2 points for running the car in Race 1, plus 2 points for finishing a lap in Race 1, and 6 points for ranking third in Race 1.","title":"Points"},{"location":"rules/#awards","text":"Teams that competed before in Race On are allowed to switch to Jetson Nano once they earn 2 or more points. Teams that accumulate 4 points or more by the end of Race 1 will receive encoders and an inertial measurement unit as an award. At the end of the competition, after Race 2, teams will be awarded an Amazon gift card in the value of $10 for each accumulated point.","title":"Awards"},{"location":"rules/#car-kit","text":"All teams compete with a car built around a 1/10 scale RC touring chassis. Distance between the front and back wheels, wheelbase, should be between 250 mm to 270 mm. Altering the contact surface of the tires is not allowed. Changing the tires to similar ones but with a different pattern is allowed. Cars should use one Mabuchi RS-540SH brushed motor to drive the car. Cars should use one battery, two LiPo cells with 7.4 V nominal and 8.4 V max, to power the car and the electronics. Converters that produce voltages above 8.4 V are not allowed. Cars should be controlled solely by a Raspberry Pi or Jetson Nano board and operate autonomously during the race. The camera must be the primary navigation sensor. Car dimensions should not exceed 12 inch width, 15 inch length, and 12 inch height with all sensors and additional boards mounted. Adding additional sensors such as accelerometer, gyroscope, encoders are allowed. Adjusting the suspension springs and weight balance, removing auxiliary chassis parts, and mounting additional boards is allowed. Additional modifications are allowed if they are easy to replicate by other teams. Attention To see whether your additional modifications are acceptable, contact Race On team before implementing them. If your modifications are illegal, you will not be allowed to compete in the races.","title":"Car Kit"},{"location":"rules/#track","text":"The racing track is built out of black segments containing white lines for delimiting the track boundary. The dimensions of a track segment are 48 inch width and 48 inch length. The white lines delimiting the track are 2 inches wide and spaced 2 inches from the edge of the track segment. Track segments are of three types, Start/Finish Line, Straight Line, and 90\u00b0 Turn. The Start/Finish segment is similar to the Straight Line segment but has two white squares in the middle which are 2 inches wide and spaced 2 inches apart.","title":"Track"},{"location":"rules/#racing-day","text":"The racing day is composed of three parts, practice session in the morning followed by the car inspection around noon and ending with the race itself in the afternoon. The exact time of each part would be announced a week before the race day.","title":"Racing Day"},{"location":"rules/#practice","text":"On the morning of the race day, each team will receive dedicate practice time on the race track. The start time and the duration of the practice session will be announced a week before. During the practice session, each time will receive 1 minute on the track and no other cars are allowed to be on the track during that time. At the end of the 1-minute practice run, teams are allowed to get back in line to request and additional minute.","title":"Practice"},{"location":"rules/#inspection","text":"Before the race starts, all cars should be handed on for inspection. The judges will inspect the cars according to requirements specified in the cars section. Violation of the requirements would be penalized with extra time or disqualified based on the severity of the violation. Cars would stay in the inspection area until the beginning of the race. No mechanical modifications are allowed after this point without approval from the judges.","title":"Inspection"},{"location":"rules/#racing","text":"Only teams that passed the inspection are allowed to race. Teams will be grouped into 30 minutes slots. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams are allocated into slots at random and find their racing order within the slot at the beginning of that slot. The team has 4 minutes in the pre-race area to set up their car and practice on a simple oval track. The team that is going to race next has priority on the practice track. After being called for racing, teams have 4 minutes to record a time. Teams have a practice run plus three attempts to finish the race and record the fastest time. The first run is considered a practice run and does not count for ranking. Teams, in order, will finish the first attempt before proceeding with the second and then the third. Cars are placed two to six feet before the finish line. During the race, cars should always be between the two white lines delimiting the track. If during the race one or more wheels completely cross the white line, the attempt is marked as failed.","title":"Racing"},{"location":"workshops/1_ros/","text":"Introduction to ROS \u00b6 ROS is an open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For Race On, however, we will focus mostly on the use of packages and message types . The power of ROS comes from the use of a computation graph similar to one used by Tensorflow, a machine learning library. The computation graph is composed from a number of nodes which either produce or consume data from multiple sources through a publish/subscribe architecture. At initialization, nodes declaretheir name and subscribe to the topics which provide all the necessary information for the node to properly function. Each topic has an associated message type which defines the format that the publishers and subscribers will use to exchange information. Some nodes might only publish data, such as the camera node, some might only subscribe to data topics, such as the motor and servo node, and some might do both such as the image processing node that receives images and outputs the car track position. ROS concepts review. Packages - In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together. Message Types - Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in the `msg folder of your package. For more info about defining a custom message type in ROS, check out creating a ROS msg and srv . Nodes - Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for Race On, we are using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics . Topics - Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. Messages - Messages are simple data structures that can contain a combination of basic data types. For a more in depth discussion of common ROS concepts, check out ROS concepts . Preparation \u00b6 Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congratulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot ROS Tutorial \u00b6 Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. If you're looking for more, here's another tutorial which provides information on creating a package in a catkin workspace . To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions how to build the C++ code, and the src is the directory where you place all your source files. To change the dependency list of your package at a later time or customize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface, navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. 1 #!/usr/bin/env python This tells the terminal that this is a Python script. All Python files should have it. 1 2 3 4 import rospy from std_msgs.msg import Float32 import math We import the Python libraries which we declared as dependencies for the tutorial package and the math library required for the to calculate the sinusoid values. The python rospy library provides all the ROS functionality to Python whereas python std_msgs library the standard message types in ROS. 1 2 RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interfaces with the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master . In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for the subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Remember to make the subscriber script executable. Exerices To better understand ROS concepts try to improve the above code by adding the following features: Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application. Create a custom message type that contains two float number. Set the value of the second float to be the cosine. Use rqt ROS tool to plot in real-time these values on your machine. Overview of Race On ROS Code \u00b6 The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them. Launch File \u00b6 The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file. Exercise \u00b6 Read through the launch file to get a better understanding of how it works. Change or remove the parameters defined in it to see how the nodes respond. Camera Node \u00b6 Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory! Position Estimation Node \u00b6 Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic . Suggested Exercise \u00b6 Try changing the peak threshold and see how it affects your estimation of the track and car positions! Controller Node \u00b6 Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic . Suggested Exercises \u00b6 Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior. Actuator Node \u00b6 Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed. Car Module \u00b6 The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car. Setting Up ROS for Your Car \u00b6 To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 .","title":"1. Introduction to ROS"},{"location":"workshops/1_ros/#introduction-to-ros","text":"ROS is an open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For Race On, however, we will focus mostly on the use of packages and message types . The power of ROS comes from the use of a computation graph similar to one used by Tensorflow, a machine learning library. The computation graph is composed from a number of nodes which either produce or consume data from multiple sources through a publish/subscribe architecture. At initialization, nodes declaretheir name and subscribe to the topics which provide all the necessary information for the node to properly function. Each topic has an associated message type which defines the format that the publishers and subscribers will use to exchange information. Some nodes might only publish data, such as the camera node, some might only subscribe to data topics, such as the motor and servo node, and some might do both such as the image processing node that receives images and outputs the car track position. ROS concepts review. Packages - In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together. Message Types - Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in the `msg folder of your package. For more info about defining a custom message type in ROS, check out creating a ROS msg and srv . Nodes - Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for Race On, we are using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics . Topics - Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. Messages - Messages are simple data structures that can contain a combination of basic data types. For a more in depth discussion of common ROS concepts, check out ROS concepts .","title":"Introduction to ROS"},{"location":"workshops/1_ros/#preparation","text":"Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congratulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot","title":"Preparation"},{"location":"workshops/1_ros/#ros-tutorial","text":"Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. If you're looking for more, here's another tutorial which provides information on creating a package in a catkin workspace . To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions how to build the C++ code, and the src is the directory where you place all your source files. To change the dependency list of your package at a later time or customize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface, navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. 1 #!/usr/bin/env python This tells the terminal that this is a Python script. All Python files should have it. 1 2 3 4 import rospy from std_msgs.msg import Float32 import math We import the Python libraries which we declared as dependencies for the tutorial package and the math library required for the to calculate the sinusoid values. The python rospy library provides all the ROS functionality to Python whereas python std_msgs library the standard message types in ROS. 1 2 RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interfaces with the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master . In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for the subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Remember to make the subscriber script executable. Exerices To better understand ROS concepts try to improve the above code by adding the following features: Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application. Create a custom message type that contains two float number. Set the value of the second float to be the cosine. Use rqt ROS tool to plot in real-time these values on your machine.","title":"ROS Tutorial"},{"location":"workshops/1_ros/#overview-of-race-on-ros-code","text":"The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them.","title":"Overview of Race On ROS Code"},{"location":"workshops/1_ros/#launch-file","text":"The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file.","title":"Launch File"},{"location":"workshops/1_ros/#exercise","text":"Read through the launch file to get a better understanding of how it works. Change or remove the parameters defined in it to see how the nodes respond.","title":"Exercise"},{"location":"workshops/1_ros/#camera-node","text":"Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file.","title":"Camera Node"},{"location":"workshops/1_ros/#suggested-exercise","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory.","title":"Suggested Exercise"},{"location":"workshops/1_ros/#suggested-exercise_1","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory!","title":"Suggested Exercise"},{"location":"workshops/1_ros/#position-estimation-node","text":"Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic .","title":"Position Estimation Node"},{"location":"workshops/1_ros/#suggested-exercise_2","text":"Try changing the peak threshold and see how it affects your estimation of the track and car positions!","title":"Suggested Exercise"},{"location":"workshops/1_ros/#controller-node","text":"Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic .","title":"Controller Node"},{"location":"workshops/1_ros/#suggested-exercises","text":"Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior.","title":"Suggested Exercises"},{"location":"workshops/1_ros/#actuator-node","text":"Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed.","title":"Actuator Node"},{"location":"workshops/1_ros/#car-module","text":"The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car.","title":"Car Module"},{"location":"workshops/1_ros/#setting-up-ros-for-your-car","text":"To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 .","title":"Setting Up ROS for Your Car"},{"location":"workshops/2_gain_scheduling/","text":"Gain Scheduling \u00b6 You assembled your car, connected it to your computer, tested the electronics, and hopefully got to run a few laps. So, what's next? Yoda has the answer for you! We have already encouraged you to improve the original self-driving code by adding integral and derivative terms to the PID controller. We will now introduce a new control technique called Gain Scheduling , which can be seen as an extension of PID. Note The following is a very simplified view of the topics. This is just to provide you an intuition of how the controllers work. Feedback Control \u00b6 Let's start with a quick recap on feedback control. One of the simplest ways to represent a typical control problem is through a block diagram. Our goal is to make the system output y as close as possible to the reference r . In order to do that, we use a sensor to measure variable y , compute the difference between current and desired value to obtain the error e and feed it to a controller. And here is where the magic happens. The controller block is responsible for transforming the measured error e into a command u which brings the system's output y closer to the reference r . Exercise : Try to identify each of the elements in the block diagram in the context of Race On. What is the system and what is the sensor? Which variables in your code are r , e , y and u ? Controllers can take very different forms. One example is the on-off mechanism of the heaters with a thermostat: the heater turns on when the temperature is below the reference and it turns off when the temperature is above the reference. Another example is the proportional controller, which can be described by u = Ke . We can also have a controller which computes system inputs based not only on the current error, but also based on the error integral and derivative. This leads to the famous PID controller . Note, the above diagram is for continuous time systems, our car is a discrete time system since we send one control command per image and not continuously while waiting for the next image. In discrete time systems the integral is replaced with the sum operator and the derivative with the difference between current and past error. The controller gains Kp , Ki , and Kd have to be selected such that the system presents the desired behavior (fast convergence to r , low overshooting etc). If we have a mathematical model of the system, there are analytical and graphical tools that help tuning the gains. In other cases, the gains are set using trial and error. Exercises : If you haven't yet, try to implement a PID controller for your car. You can reference this pseudocode . Search online for hints on how to tune the different gains. What are the expected effects of increasing/decreasing each one of them? Step Response \u00b6 Before we dive deeper into more advanced controllers, we first need to know how to measure the performance of different controllers. The most simple and at the same time informative method is the step response shown in the figure below. The step response is obtained by suddenly cheanging the reference from one value to another, in the figure above is from zero to one, and tracking how the controller responds to this change. To get a step response using you car, run the car on a straight line and after one second switch the reference value from CAMERA_CENTER to CAMERA_CENTER - 100 and save the values of line_pos into an array, stop the car after a timeout and plot the array to see the step response. Repeat with a step in a different direction CAMERA_CENTER + 100 to make sure your car responds to left and right turns equally. The most important metrics of the step response are rise time , overshoot , and settling time .We want a fast rise time with no overshoot and low settling time, however, in practice we have to accept a tradeoff as optimizing all three at the same time is most of the time impossible. Rise time is defined as the time from when the reference value changed until we reach the new reference (or 0.9 of the new refence value). A high gain (high value of the proportional and derivative coefficients) leads to a fast response time but also to an overshoot. Overshoot defines by how much we miss the new reference once we reach the new reference value for the first time. A high overshoot can make you car run off the track as you exit the turn, but a small overshoot can be tolerated and help decreases the rise time. Settling time is the time between the reference change and the time the system stabilizes around it. A low settling time helps if there are a sequence of turns as the car will stay closer to the reference. Gain Scheduling \u00b6 A well tuned PID controller can yield very good performance. However, what happens if the operating condition changes? Airplanes are a good example. The system behaves remarkably different at take-off, in-flight and on landing. In these cases, the gains tuned for one operating condition might not lead to the desired behavior when the system is at another operating point. One possible solution to this problem is gain scheduling. It is usually done in 4 steps: Define the different system operating conditions; Tune your controller gains for each operating condition. This will create an array (or a table) of controller gains; Determine how to vary the controller gains based on the operating conditions; Assess system performance. Steps 1, 2, and 4 are the same as you would do for a regular PID controller. Step 3 is the fun part! The main options are: Simple switch : change the gains when the system is at a different operating point. The advantage of this method is its simplicity. However, this creates discontinuities. If the error is 2 and the gain changes from 2 to 5, your control input jumps from 4 to 10! This can damage actuators or create undesirable system behavior. Transient switch : when the operation conditions change, linearly change from one gain to the other within a certain time interval. The trick here is to choose the time interval long enough to create a smooth transient but short enough to allow the controller to respond properly to the operating condition change. Interpolate between gains : we can avoid switching by creating a curve that smoothly changes between gains continuously. This is possible when the operating conditions also change continuously. The three cases are illustrated below, where tc is the time when the operating condition change is identified, and T is the transient time for the transient switch approach. For a more in depth introduction to gain scheduling, we recommend watching this video . Applied to Race On \u00b6 For now, let's assume your car is set to a constant speed and we only want to control the position relative to the center of the track. We will reference the original code provided with the car but it should be easy to adapt these instructions to your modified code. If you have any issues with it, remember you can always check the original code at the race on github. We follow the 4 steps described previously: Define the different system operating conditions. Even though the car itself doesn't change much during the race, the track varies considerably. We can define three different operating modes for the car: straight line, 90 o turn and 180 o turn. Next, we have to find a way to identify these conditions. One way of doing this is by looking at the error. This requires a few steps and some tuning. Let's get to it! Create an error array in your code before the loop starts and populate the array at every iteration: 1 2 3 4 5 error_array = [] for f in stream : [ ... ] error = CAMERA_CENTER - line_pos error_array . append ( error ) Then, run a lap on the track and plot your error with the command plt.plot(error_array) . You should be able to map different peaks and valleys on your error plot to straight lines, 90 o and 180 o turns on the track. After this, you can create thresholds to identify when the car is in each of these scenarios. Tune your controller gains for each operating condition. While it's complicated to tune the controller individually for each operating condition, we can use our knowledge of the problem to estimate how the gains should change. Intuitively, an error on a straight line doesn't need to be corrected as aggressively as errors on turns. Therefore, let's define: 1 2 3 K_0 = 5000 K_90 = 7000 K_180 = 9000 Determine how to vary the controller gains based on the operating conditions We will use a simple discrete switch. Based on your observation of the errors, create thresholds and use them to choose your gain: 1 2 3 4 5 6 7 8 9 10 11 12 e_90 = 50 e_180 = 75 [ ... ] for f in stream : [ ... ] gain = K_0 if error > e_180 : gain = K_180 elif error > e_90 : gain = K_90 DUTY_CYCLE = SERVO_MIDDLE + gain * error Assess system performance. Use the error plot to check your car performance on the track. Is it overshooting after turns? Does it take too long to realize it's in a turn? Or maybe it takes too long to realize it's back on a straight line? You should adjust the gains and thresholds to optimize your controller and start doing some aggressive turns! Exercises You probably noticed our example only covers the proportional gain. Include integral and derivative gains in your gain scheduling routine. Test the same approach for speed scheduling. Define three different speeds (one for each operating condition) and switch among them to see if you can get faster laps. This is just one of numerous ways to apply gain scheduling to your vehicle controller. You are encouraged to try other approaches!","title":"2. Gain Scheduling"},{"location":"workshops/2_gain_scheduling/#gain-scheduling","text":"You assembled your car, connected it to your computer, tested the electronics, and hopefully got to run a few laps. So, what's next? Yoda has the answer for you! We have already encouraged you to improve the original self-driving code by adding integral and derivative terms to the PID controller. We will now introduce a new control technique called Gain Scheduling , which can be seen as an extension of PID. Note The following is a very simplified view of the topics. This is just to provide you an intuition of how the controllers work.","title":"Gain Scheduling"},{"location":"workshops/2_gain_scheduling/#feedback-control","text":"Let's start with a quick recap on feedback control. One of the simplest ways to represent a typical control problem is through a block diagram. Our goal is to make the system output y as close as possible to the reference r . In order to do that, we use a sensor to measure variable y , compute the difference between current and desired value to obtain the error e and feed it to a controller. And here is where the magic happens. The controller block is responsible for transforming the measured error e into a command u which brings the system's output y closer to the reference r . Exercise : Try to identify each of the elements in the block diagram in the context of Race On. What is the system and what is the sensor? Which variables in your code are r , e , y and u ? Controllers can take very different forms. One example is the on-off mechanism of the heaters with a thermostat: the heater turns on when the temperature is below the reference and it turns off when the temperature is above the reference. Another example is the proportional controller, which can be described by u = Ke . We can also have a controller which computes system inputs based not only on the current error, but also based on the error integral and derivative. This leads to the famous PID controller . Note, the above diagram is for continuous time systems, our car is a discrete time system since we send one control command per image and not continuously while waiting for the next image. In discrete time systems the integral is replaced with the sum operator and the derivative with the difference between current and past error. The controller gains Kp , Ki , and Kd have to be selected such that the system presents the desired behavior (fast convergence to r , low overshooting etc). If we have a mathematical model of the system, there are analytical and graphical tools that help tuning the gains. In other cases, the gains are set using trial and error. Exercises : If you haven't yet, try to implement a PID controller for your car. You can reference this pseudocode . Search online for hints on how to tune the different gains. What are the expected effects of increasing/decreasing each one of them?","title":"Feedback Control"},{"location":"workshops/2_gain_scheduling/#step-response","text":"Before we dive deeper into more advanced controllers, we first need to know how to measure the performance of different controllers. The most simple and at the same time informative method is the step response shown in the figure below. The step response is obtained by suddenly cheanging the reference from one value to another, in the figure above is from zero to one, and tracking how the controller responds to this change. To get a step response using you car, run the car on a straight line and after one second switch the reference value from CAMERA_CENTER to CAMERA_CENTER - 100 and save the values of line_pos into an array, stop the car after a timeout and plot the array to see the step response. Repeat with a step in a different direction CAMERA_CENTER + 100 to make sure your car responds to left and right turns equally. The most important metrics of the step response are rise time , overshoot , and settling time .We want a fast rise time with no overshoot and low settling time, however, in practice we have to accept a tradeoff as optimizing all three at the same time is most of the time impossible. Rise time is defined as the time from when the reference value changed until we reach the new reference (or 0.9 of the new refence value). A high gain (high value of the proportional and derivative coefficients) leads to a fast response time but also to an overshoot. Overshoot defines by how much we miss the new reference once we reach the new reference value for the first time. A high overshoot can make you car run off the track as you exit the turn, but a small overshoot can be tolerated and help decreases the rise time. Settling time is the time between the reference change and the time the system stabilizes around it. A low settling time helps if there are a sequence of turns as the car will stay closer to the reference.","title":"Step Response"},{"location":"workshops/2_gain_scheduling/#gain-scheduling_1","text":"A well tuned PID controller can yield very good performance. However, what happens if the operating condition changes? Airplanes are a good example. The system behaves remarkably different at take-off, in-flight and on landing. In these cases, the gains tuned for one operating condition might not lead to the desired behavior when the system is at another operating point. One possible solution to this problem is gain scheduling. It is usually done in 4 steps: Define the different system operating conditions; Tune your controller gains for each operating condition. This will create an array (or a table) of controller gains; Determine how to vary the controller gains based on the operating conditions; Assess system performance. Steps 1, 2, and 4 are the same as you would do for a regular PID controller. Step 3 is the fun part! The main options are: Simple switch : change the gains when the system is at a different operating point. The advantage of this method is its simplicity. However, this creates discontinuities. If the error is 2 and the gain changes from 2 to 5, your control input jumps from 4 to 10! This can damage actuators or create undesirable system behavior. Transient switch : when the operation conditions change, linearly change from one gain to the other within a certain time interval. The trick here is to choose the time interval long enough to create a smooth transient but short enough to allow the controller to respond properly to the operating condition change. Interpolate between gains : we can avoid switching by creating a curve that smoothly changes between gains continuously. This is possible when the operating conditions also change continuously. The three cases are illustrated below, where tc is the time when the operating condition change is identified, and T is the transient time for the transient switch approach. For a more in depth introduction to gain scheduling, we recommend watching this video .","title":"Gain Scheduling"},{"location":"workshops/2_gain_scheduling/#applied-to-race-on","text":"For now, let's assume your car is set to a constant speed and we only want to control the position relative to the center of the track. We will reference the original code provided with the car but it should be easy to adapt these instructions to your modified code. If you have any issues with it, remember you can always check the original code at the race on github. We follow the 4 steps described previously: Define the different system operating conditions. Even though the car itself doesn't change much during the race, the track varies considerably. We can define three different operating modes for the car: straight line, 90 o turn and 180 o turn. Next, we have to find a way to identify these conditions. One way of doing this is by looking at the error. This requires a few steps and some tuning. Let's get to it! Create an error array in your code before the loop starts and populate the array at every iteration: 1 2 3 4 5 error_array = [] for f in stream : [ ... ] error = CAMERA_CENTER - line_pos error_array . append ( error ) Then, run a lap on the track and plot your error with the command plt.plot(error_array) . You should be able to map different peaks and valleys on your error plot to straight lines, 90 o and 180 o turns on the track. After this, you can create thresholds to identify when the car is in each of these scenarios. Tune your controller gains for each operating condition. While it's complicated to tune the controller individually for each operating condition, we can use our knowledge of the problem to estimate how the gains should change. Intuitively, an error on a straight line doesn't need to be corrected as aggressively as errors on turns. Therefore, let's define: 1 2 3 K_0 = 5000 K_90 = 7000 K_180 = 9000 Determine how to vary the controller gains based on the operating conditions We will use a simple discrete switch. Based on your observation of the errors, create thresholds and use them to choose your gain: 1 2 3 4 5 6 7 8 9 10 11 12 e_90 = 50 e_180 = 75 [ ... ] for f in stream : [ ... ] gain = K_0 if error > e_180 : gain = K_180 elif error > e_90 : gain = K_90 DUTY_CYCLE = SERVO_MIDDLE + gain * error Assess system performance. Use the error plot to check your car performance on the track. Is it overshooting after turns? Does it take too long to realize it's in a turn? Or maybe it takes too long to realize it's back on a straight line? You should adjust the gains and thresholds to optimize your controller and start doing some aggressive turns! Exercises You probably noticed our example only covers the proportional gain. Include integral and derivative gains in your gain scheduling routine. Test the same approach for speed scheduling. Define three different speeds (one for each operating condition) and switch among them to see if you can get faster laps. This is just one of numerous ways to apply gain scheduling to your vehicle controller. You are encouraged to try other approaches!","title":"Applied to Race On"}]}