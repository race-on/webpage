{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Race On \u2013 USC Self-Driving Car Competition \u00b6 Announcements \u00b6 \ud83c\udfc1\ud83c\udfce.. Race 0 Info Race 0 Practice Session - Feb. 7, 2020 - 5pm to 9pm @ EEB 132 Race 0 Actual Race - Feb. 8, 2020 - 9 am to 3pm @ EEB 132 9am to 11:30am - Dedicated practice time. Each team can request 1 minute on the track and no other cars are allowed to be on the track during that time. 11:30 to 1pm - Car inspection plus lunch break. 1pm to 3pm - Racing \ud83c\udfce. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams, please take note of the racing order details as sent in this week's newsletter to know which time slot you are allotted. Goal : We expect all of you to have a fully functional car on Saturday and successfully complete a lap on the oval track. But to remove some pressure, we will reward 2 points to every team that runs the car on the track regardless if you finish a lap or not . Challenge Overview \u00b6 The goal of this competition is to engage students in hardware-software development of a self-driving car for racing. Teams of 2 to 4 students compete to build the fastest car and have one semester to prepare for the two races, when all cars, turn by turn, race to record the fastest time. The competition is for USC Viterbi masters students and undergraduate juniors and seniors, regardless of Viterbi program or year. Sophomore undergraduate students are also welcome; however, the difficulty of this competition may be more appropriate for more experienced students. Students are not expected to have prior experience with self-driving cars. Teams will receive instructions how to assemble a car from scratch and program the control algorithm of a self-driving car. All cars are built on the same platform and race against each other on the same track configurations, thus innovation and creativity is what counts. To help the teams get started, a series of workshops on embedded hardware and software concepts will be organized to provide technical support to the students especially during the initial phase of the race. In addition, optional weekly sessions are to be held where teams can work on their projects and interact with other teams. Though these workshops are meant to help the teams develop their car, outside work on the project will be necessary, since an exceptional car will require thoughtful optimization to excel. With these workshops as a starting place, teams are given the unique opportunity to apply their technical knowledge and creative abilities to a real-world situation. Fees and Prizes \u00b6 For new teams, the fee to participate in Race On is $250 per team . This fee covers all the materials needed to assemble a self-driving car, such as the car kit, raspberry pi plus other components and accessories. Teams can get $100 back along with additional sensors and components by actively participating in races. Winning teams even stand a chance to win up to $400 . See Rules section for details. Car Kit \u00b6 Upon registration, new teams will receive their car, described below. Teams with returning members will use their previous car. The car is built around a 1/10 scale RC touring chassis powered by a brushed motor and a 2\u2013cell LiPo battery. The Raspberry Pi microprocessor through image processing will detect the track from the images supplied by a camera and adjust the steering angle and the motor speed to keep the car on the track. The images below show the assembled car, the camera and the Raspberry Pi board that when assemble form the car to be raced. The chassis, battery and the motor are regulated to ensure that no team gains an advantage through better components, and that creativity and superior programming differentiate the teams. Modifications of the chassis are allowed as long as the changes follow the competition rules. Moreover, more sensors can be added as long as the camera remains the main sensor used for steering the car. Cars are permitted to have a wireless connection with a computer for development and calibration, however, during the final race the car should operate autonomously and no external connection is permitted. All cars will be inspected before the final race and only the ones which comply with the above rules will be allowed to compete.","title":"Home"},{"location":"#race-on-usc-self-driving-car-competition","text":"","title":"Race On \u2013 USC Self-Driving Car Competition"},{"location":"#announcements","text":"\ud83c\udfc1\ud83c\udfce.. Race 0 Info Race 0 Practice Session - Feb. 7, 2020 - 5pm to 9pm @ EEB 132 Race 0 Actual Race - Feb. 8, 2020 - 9 am to 3pm @ EEB 132 9am to 11:30am - Dedicated practice time. Each team can request 1 minute on the track and no other cars are allowed to be on the track during that time. 11:30 to 1pm - Car inspection plus lunch break. 1pm to 3pm - Racing \ud83c\udfce. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams, please take note of the racing order details as sent in this week's newsletter to know which time slot you are allotted. Goal : We expect all of you to have a fully functional car on Saturday and successfully complete a lap on the oval track. But to remove some pressure, we will reward 2 points to every team that runs the car on the track regardless if you finish a lap or not .","title":"Announcements"},{"location":"#challenge-overview","text":"The goal of this competition is to engage students in hardware-software development of a self-driving car for racing. Teams of 2 to 4 students compete to build the fastest car and have one semester to prepare for the two races, when all cars, turn by turn, race to record the fastest time. The competition is for USC Viterbi masters students and undergraduate juniors and seniors, regardless of Viterbi program or year. Sophomore undergraduate students are also welcome; however, the difficulty of this competition may be more appropriate for more experienced students. Students are not expected to have prior experience with self-driving cars. Teams will receive instructions how to assemble a car from scratch and program the control algorithm of a self-driving car. All cars are built on the same platform and race against each other on the same track configurations, thus innovation and creativity is what counts. To help the teams get started, a series of workshops on embedded hardware and software concepts will be organized to provide technical support to the students especially during the initial phase of the race. In addition, optional weekly sessions are to be held where teams can work on their projects and interact with other teams. Though these workshops are meant to help the teams develop their car, outside work on the project will be necessary, since an exceptional car will require thoughtful optimization to excel. With these workshops as a starting place, teams are given the unique opportunity to apply their technical knowledge and creative abilities to a real-world situation.","title":"Challenge Overview"},{"location":"#fees-and-prizes","text":"For new teams, the fee to participate in Race On is $250 per team . This fee covers all the materials needed to assemble a self-driving car, such as the car kit, raspberry pi plus other components and accessories. Teams can get $100 back along with additional sensors and components by actively participating in races. Winning teams even stand a chance to win up to $400 . See Rules section for details.","title":"Fees and Prizes"},{"location":"#car-kit","text":"Upon registration, new teams will receive their car, described below. Teams with returning members will use their previous car. The car is built around a 1/10 scale RC touring chassis powered by a brushed motor and a 2\u2013cell LiPo battery. The Raspberry Pi microprocessor through image processing will detect the track from the images supplied by a camera and adjust the steering angle and the motor speed to keep the car on the track. The images below show the assembled car, the camera and the Raspberry Pi board that when assemble form the car to be raced. The chassis, battery and the motor are regulated to ensure that no team gains an advantage through better components, and that creativity and superior programming differentiate the teams. Modifications of the chassis are allowed as long as the changes follow the competition rules. Moreover, more sensors can be added as long as the camera remains the main sensor used for steering the car. Cars are permitted to have a wireless connection with a computer for development and calibration, however, during the final race the car should operate autonomously and no external connection is permitted. All cars will be inspected before the final race and only the ones which comply with the above rules will be allowed to compete.","title":"Car Kit"},{"location":"registration/","text":"Spring 2020 Registration \u00b6 Thank you for your interest; however, the Race On Spring 2020 Registration is now closed :( To be kept in the loop regarding the current Spring 2020 Race On event as well as information on the upcoming Race On Fall 2020 registration , please subscribe to our newsletter (link found on the right).","title":"Registration"},{"location":"registration/#spring-2020-registration","text":"Thank you for your interest; however, the Race On Spring 2020 Registration is now closed :( To be kept in the loop regarding the current Spring 2020 Race On event as well as information on the upcoming Race On Fall 2020 registration , please subscribe to our newsletter (link found on the right).","title":"Spring 2020 Registration"},{"location":"ros/","text":"What is ROS? \u00b6 Ros is open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. Read more about ROS here. Ros Concepts \u00b6 ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For RaceOn, however, we'll focus mostly on the use of packages and message types . Additionally, ROS has several important concepts related to its \"computation graph\". \"The Computation Graph is the peer-to-peer network of ROS processes that are processing data together.\" For the sake of Race On, the computation graph is composed of a number of ROS nodes that communicate through a publish/subscribe architecture. The pieces of the computational graph that are most relevant to RaceOn are nodes , messages , and topics . For an overview of ROS concepts, read here . Packages \u00b6 In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together. Message Types \u00b6 Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in my_package/msg/MyMessageType.msg . For more info about defining a custom message type in ROS, check out creating a ROS msg and srv . Nodes \u00b6 Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for RaceOn, we're using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics . Messages \u00b6 Messages are simple data structures that can contain a combination of basic data types. Topics \u00b6 Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. This is a classic ROS tutorial for setting up publisher and subscriber nodes. For a more in depth discussion of common ROS concepts, check out ROS concepts . Preparation \u00b6 Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congradulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot ROS Tutorial \u00b6 Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions on how to build the C++ code, and src is the directory where you place all your source files. To change the dependency list of your package at a later time or custumize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"Node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. First line tells the terminal that this is a Python script. All Python files should have it. The next three lines import the Python libraries which we declared as dependency for the tutorial package and the math library required for the to calculate the sinusoid values. Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interface to the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Exerices To better understan ROS concepts try to improve the above code by adding the following two features: 1. Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration 1. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application. Setting Up ROS for Your Car \u00b6 To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 . Overview of Race On ROS Code \u00b6 The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them. Launch File \u00b6 The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file. Camera Node \u00b6 Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory! Position Estimation Node \u00b6 Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic . Suggested Exercise \u00b6 Try changing the peak threshold and see how it affects your estimation of the track and car positions! Controller Node \u00b6 Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic . Suggested Exercises \u00b6 Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior. Actuator Node \u00b6 Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed. Car Module \u00b6 The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car.","title":"Ros Overview Setup"},{"location":"ros/#what-is-ros","text":"Ros is open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. Read more about ROS here.","title":"What is ROS?"},{"location":"ros/#ros-concepts","text":"ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For RaceOn, however, we'll focus mostly on the use of packages and message types . Additionally, ROS has several important concepts related to its \"computation graph\". \"The Computation Graph is the peer-to-peer network of ROS processes that are processing data together.\" For the sake of Race On, the computation graph is composed of a number of ROS nodes that communicate through a publish/subscribe architecture. The pieces of the computational graph that are most relevant to RaceOn are nodes , messages , and topics . For an overview of ROS concepts, read here .","title":"Ros Concepts"},{"location":"ros/#packages","text":"In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together.","title":"Packages"},{"location":"ros/#message-types","text":"Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in my_package/msg/MyMessageType.msg . For more info about defining a custom message type in ROS, check out creating a ROS msg and srv .","title":"Message Types"},{"location":"ros/#nodes","text":"Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for RaceOn, we're using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics .","title":"Nodes"},{"location":"ros/#messages","text":"Messages are simple data structures that can contain a combination of basic data types.","title":"Messages"},{"location":"ros/#topics","text":"Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. This is a classic ROS tutorial for setting up publisher and subscriber nodes. For a more in depth discussion of common ROS concepts, check out ROS concepts .","title":"Topics"},{"location":"ros/#preparation","text":"Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congradulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot","title":"Preparation"},{"location":"ros/#ros-tutorial","text":"Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions on how to build the C++ code, and src is the directory where you place all your source files. To change the dependency list of your package at a later time or custumize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"Node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. First line tells the terminal that this is a Python script. All Python files should have it. The next three lines import the Python libraries which we declared as dependency for the tutorial package and the math library required for the to calculate the sinusoid values. Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interface to the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Exerices To better understan ROS concepts try to improve the above code by adding the following two features: 1. Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration 1. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application.","title":"ROS Tutorial"},{"location":"ros/#setting-up-ros-for-your-car","text":"To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 .","title":"Setting Up ROS for Your Car"},{"location":"ros/#overview-of-race-on-ros-code","text":"The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them.","title":"Overview of Race On ROS Code"},{"location":"ros/#launch-file","text":"The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file.","title":"Launch File"},{"location":"ros/#camera-node","text":"Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file.","title":"Camera Node"},{"location":"ros/#suggested-exercise","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory.","title":"Suggested Exercise"},{"location":"ros/#suggested-exercise_1","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory!","title":"Suggested Exercise"},{"location":"ros/#position-estimation-node","text":"Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic .","title":"Position Estimation Node"},{"location":"ros/#suggested-exercise_2","text":"Try changing the peak threshold and see how it affects your estimation of the track and car positions!","title":"Suggested Exercise"},{"location":"ros/#controller-node","text":"Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic .","title":"Controller Node"},{"location":"ros/#suggested-exercises","text":"Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior.","title":"Suggested Exercises"},{"location":"ros/#actuator-node","text":"Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed.","title":"Actuator Node"},{"location":"ros/#car-module","text":"The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car.","title":"Car Module"},{"location":"rules/","text":"Rules \u2013 Spring 2020 \u00b6 Registration \u00b6 Registration for the Spring 2020 edition is open until Sunday, January 19 . Teams that register must pay $250 materials fee if all members are new to Race On. Teams where one or more team members competed in a previous Race On competition still have to register online but do not pay the materials fee. We encourage teams to reuse previously received cars and we can help replace certain components. Teams are formed of two to four students that are currently enrolled at USC and are the only ones who build, program, and race the car. Each team delegates a contact person that will represent the team. All teams compete in the same races and on the same racing track irrespective of their program and year of study. Students are required to exhibit appropriate sportsmanship behavior and any attempts of cheating would result in penalties or disqualification. Races \u00b6 Race On competition consists of three races with mandatory participation. Date Room Race 0 Saturday, February 8 EEB 132 Race 1 Saturday, February 29 EEB 132 Race 2 Friday, April 17 EEB 132 Teams are awarded points based on their performance in each race. In Race 0, teams will race on a simple loop track. The goal of this race is to stimulate teams to finish assembling their cars. In Race 1, teams will race on an average complexity track and will be awarded points for both participation and ranking. In Race 2 teams will race on a longer and more complex track. Teams will receive points for completing a lap and the ranking points will be double compared to the first race. Points \u00b6 Note The point system is designed such that a team that did average in Race 1 can still win the competition if they improve for Race 2. The best team from Race 1 does not automatically win if they do average in Race 2. However, winning Race 1 helps break some ties in the final standings. In all three races, teams will be awarded points for running the car, finishing a lap, and ranking in the top five in each race. Race 0 Race 1 Race 2 Run 2 2 - Lap - 2 4 Rank 1 - 10 20 Rank 2 - 8 16 Rank 3 - 6 12 Rank 4 - 4 8 Rank 5 - 2 4 Run points will be awarded in Race 0 and Race 1. Teams that manage to run their car, car moves autonomously on the track, will receive 2 points. Lap points will be awarded in Race 1 and Race 2. Teams that complete a lap would receive 2 points in Race 1 and 4 points in Race 2. Ranking points will be awarded in Race 1 and Race 2. The top five teams that have the fastest time will be awarded ranking points based on the table below. The ranking points of Race 2 are double of the ones from Race 1. The team score is the sum of the points accumulated in all the races. This final score will be compared against the final score of all the teams to determine the final ranking. The team with the most points wins. If multiple teams have the same number of points, they will receive the same ranking. Example Team 1 manages to assemble the car for Race 0 and run it on the track. In Race 1, the team runs the car but does not complete a lap, and in Race 2, the team finishes the lap and it is the fastest lap of all teams. As a result, Team 1 will receive 28 points: 2 points for running the car in Race 0, plus 2 points for running the car in Race 1, plus 4 points for finishing a lap in Race 2, and 20 points for ranking first in Race 2. Team 2 does not manage to assemble the car for Race 0. In Race 1 they finish a lap and rank third and in Race 2 the car runs on the track but does not complete a lap. As a result, team 2 will receive 10 points: 2 points for running the car in Race 1, plus 2 points for finishing a lap in Race 1, and 6 points for ranking third in Race 1. Awards \u00b6 Teams that competed before in Race On are allowed to switch to Jetson Nano once they earn 2 or more points. Teams that accumulate 4 points or more by the end of Race 1 will receive encoders and an inertial measurement unit as an award. At the end of the competition, after Race 2, teams will be awarded an Amazon gift card in the value of $10 for each accumulated point. Car Kit \u00b6 All teams compete with a car built around a 1/10 scale RC touring chassis. Distance between the front and back wheels, wheelbase, should be between 250 mm to 270 mm. Altering the contact surface of the tires is not allowed. Changing the tires to similar ones but with a different pattern is allowed. Cars should use one Mabuchi RS-540SH brushed motor to drive the car. Cars should use one battery, two LiPo cells with 7.4 V nominal and 8.4 V max, to power the car and the electronics. Converters that produce voltages above 8.4 V are not allowed. Cars should be controlled solely by a Raspberry Pi or Jetson Nano board and operate autonomously during the race. The camera must be the primary navigation sensor. Car dimensions should not exceed 12 inch width, 15 inch length, and 12 inch height with all sensors and additional boards mounted. Adding additional sensors such as accelerometer, gyroscope, encoders are allowed. Adjusting the suspension springs and weight balance, removing auxiliary chassis parts, and mounting additional boards is allowed. Additional modifications are allowed if they are easy to replicate by other teams. Attention To see whether your additional modifications are acceptable, contact Race On team before implementing them. If your modifications are illegal, you will not be allowed to compete in the races. Track \u00b6 The racing track is built out of black segments containing white lines for delimiting the track boundary. The dimensions of a track segment are 48 inch width and 48 inch length. The white lines delimiting the track are 2 inches wide and spaced 2 inches from the edge of the track segment. Track segments are of three types, Start/Finish Line, Straight Line, and 90\u00b0 Turn. The Start/Finish segment is similar to the Straight Line segment but has two white squares in the middle which are 2 inches wide and spaced 2 inches apart. Racing Day \u00b6 The racing day is composed of three parts, practice session in the morning followed by the car inspection around noon and ending with the race itself in the afternoon. The exact time of each part would be announced a week before the race day. Practice \u00b6 On the morning of the race day, each team will receive dedicate practice time on the race track. The start time and the duration of the practice session will be announced a week before. During the practice session, each time will receive 1 minute on the track and no other cars are allowed to be on the track during that time. At the end of the 1-minute practice run, teams are allowed to get back in line to request and additional minute. Inspection \u00b6 Before the race starts, all cars should be handed on for inspection. The judges will inspect the cars according to requirements specified in the cars section. Violation of the requirements would be penalized with extra time or disqualified based on the severity of the violation. Cars would stay in the inspection area until the beginning of the race. No mechanical modifications are allowed after this point without approval from the judges. Racing \u00b6 Only teams that passed the inspection are allowed to race. Teams will be grouped into 30 minutes slots. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams are allocated into slots at random and find their racing order within the slot at the beginning of that slot. The team has 4 minutes in the pre-race area to set up their car and practice on a simple oval track. The team that is going to race next has priority on the practice track. After being called for racing, teams have 4 minutes to record a time. Teams have a practice run plus three attempts to finish the race and record the fastest time. The first run is considered a practice run and does not count for ranking. Teams, in order, will finish the first attempt before proceeding with the second and then the third. Cars are placed two to six feet before the finish line. During the race, cars should always be between the two white lines delimiting the track. If during the race one or more wheels completely cross the white line, the attempt is marked as failed.","title":"Rules"},{"location":"rules/#rules-spring-2020","text":"","title":"Rules \u2013 Spring 2020"},{"location":"rules/#registration","text":"Registration for the Spring 2020 edition is open until Sunday, January 19 . Teams that register must pay $250 materials fee if all members are new to Race On. Teams where one or more team members competed in a previous Race On competition still have to register online but do not pay the materials fee. We encourage teams to reuse previously received cars and we can help replace certain components. Teams are formed of two to four students that are currently enrolled at USC and are the only ones who build, program, and race the car. Each team delegates a contact person that will represent the team. All teams compete in the same races and on the same racing track irrespective of their program and year of study. Students are required to exhibit appropriate sportsmanship behavior and any attempts of cheating would result in penalties or disqualification.","title":"Registration"},{"location":"rules/#races","text":"Race On competition consists of three races with mandatory participation. Date Room Race 0 Saturday, February 8 EEB 132 Race 1 Saturday, February 29 EEB 132 Race 2 Friday, April 17 EEB 132 Teams are awarded points based on their performance in each race. In Race 0, teams will race on a simple loop track. The goal of this race is to stimulate teams to finish assembling their cars. In Race 1, teams will race on an average complexity track and will be awarded points for both participation and ranking. In Race 2 teams will race on a longer and more complex track. Teams will receive points for completing a lap and the ranking points will be double compared to the first race.","title":"Races"},{"location":"rules/#points","text":"Note The point system is designed such that a team that did average in Race 1 can still win the competition if they improve for Race 2. The best team from Race 1 does not automatically win if they do average in Race 2. However, winning Race 1 helps break some ties in the final standings. In all three races, teams will be awarded points for running the car, finishing a lap, and ranking in the top five in each race. Race 0 Race 1 Race 2 Run 2 2 - Lap - 2 4 Rank 1 - 10 20 Rank 2 - 8 16 Rank 3 - 6 12 Rank 4 - 4 8 Rank 5 - 2 4 Run points will be awarded in Race 0 and Race 1. Teams that manage to run their car, car moves autonomously on the track, will receive 2 points. Lap points will be awarded in Race 1 and Race 2. Teams that complete a lap would receive 2 points in Race 1 and 4 points in Race 2. Ranking points will be awarded in Race 1 and Race 2. The top five teams that have the fastest time will be awarded ranking points based on the table below. The ranking points of Race 2 are double of the ones from Race 1. The team score is the sum of the points accumulated in all the races. This final score will be compared against the final score of all the teams to determine the final ranking. The team with the most points wins. If multiple teams have the same number of points, they will receive the same ranking. Example Team 1 manages to assemble the car for Race 0 and run it on the track. In Race 1, the team runs the car but does not complete a lap, and in Race 2, the team finishes the lap and it is the fastest lap of all teams. As a result, Team 1 will receive 28 points: 2 points for running the car in Race 0, plus 2 points for running the car in Race 1, plus 4 points for finishing a lap in Race 2, and 20 points for ranking first in Race 2. Team 2 does not manage to assemble the car for Race 0. In Race 1 they finish a lap and rank third and in Race 2 the car runs on the track but does not complete a lap. As a result, team 2 will receive 10 points: 2 points for running the car in Race 1, plus 2 points for finishing a lap in Race 1, and 6 points for ranking third in Race 1.","title":"Points"},{"location":"rules/#awards","text":"Teams that competed before in Race On are allowed to switch to Jetson Nano once they earn 2 or more points. Teams that accumulate 4 points or more by the end of Race 1 will receive encoders and an inertial measurement unit as an award. At the end of the competition, after Race 2, teams will be awarded an Amazon gift card in the value of $10 for each accumulated point.","title":"Awards"},{"location":"rules/#car-kit","text":"All teams compete with a car built around a 1/10 scale RC touring chassis. Distance between the front and back wheels, wheelbase, should be between 250 mm to 270 mm. Altering the contact surface of the tires is not allowed. Changing the tires to similar ones but with a different pattern is allowed. Cars should use one Mabuchi RS-540SH brushed motor to drive the car. Cars should use one battery, two LiPo cells with 7.4 V nominal and 8.4 V max, to power the car and the electronics. Converters that produce voltages above 8.4 V are not allowed. Cars should be controlled solely by a Raspberry Pi or Jetson Nano board and operate autonomously during the race. The camera must be the primary navigation sensor. Car dimensions should not exceed 12 inch width, 15 inch length, and 12 inch height with all sensors and additional boards mounted. Adding additional sensors such as accelerometer, gyroscope, encoders are allowed. Adjusting the suspension springs and weight balance, removing auxiliary chassis parts, and mounting additional boards is allowed. Additional modifications are allowed if they are easy to replicate by other teams. Attention To see whether your additional modifications are acceptable, contact Race On team before implementing them. If your modifications are illegal, you will not be allowed to compete in the races.","title":"Car Kit"},{"location":"rules/#track","text":"The racing track is built out of black segments containing white lines for delimiting the track boundary. The dimensions of a track segment are 48 inch width and 48 inch length. The white lines delimiting the track are 2 inches wide and spaced 2 inches from the edge of the track segment. Track segments are of three types, Start/Finish Line, Straight Line, and 90\u00b0 Turn. The Start/Finish segment is similar to the Straight Line segment but has two white squares in the middle which are 2 inches wide and spaced 2 inches apart.","title":"Track"},{"location":"rules/#racing-day","text":"The racing day is composed of three parts, practice session in the morning followed by the car inspection around noon and ending with the race itself in the afternoon. The exact time of each part would be announced a week before the race day.","title":"Racing Day"},{"location":"rules/#practice","text":"On the morning of the race day, each team will receive dedicate practice time on the race track. The start time and the duration of the practice session will be announced a week before. During the practice session, each time will receive 1 minute on the track and no other cars are allowed to be on the track during that time. At the end of the 1-minute practice run, teams are allowed to get back in line to request and additional minute.","title":"Practice"},{"location":"rules/#inspection","text":"Before the race starts, all cars should be handed on for inspection. The judges will inspect the cars according to requirements specified in the cars section. Violation of the requirements would be penalized with extra time or disqualified based on the severity of the violation. Cars would stay in the inspection area until the beginning of the race. No mechanical modifications are allowed after this point without approval from the judges.","title":"Inspection"},{"location":"rules/#racing","text":"Only teams that passed the inspection are allowed to race. Teams will be grouped into 30 minutes slots. At the beginning of each slot, all the teams in that slot are required to come to the pre-race area to pick up their car. Teams are allocated into slots at random and find their racing order within the slot at the beginning of that slot. The team has 4 minutes in the pre-race area to set up their car and practice on a simple oval track. The team that is going to race next has priority on the practice track. After being called for racing, teams have 4 minutes to record a time. Teams have a practice run plus three attempts to finish the race and record the fastest time. The first run is considered a practice run and does not count for ranking. Teams, in order, will finish the first attempt before proceeding with the second and then the third. Cars are placed two to six feet before the finish line. During the race, cars should always be between the two white lines delimiting the track. If during the race one or more wheels completely cross the white line, the attempt is marked as failed.","title":"Racing"},{"location":"Workshops/ros/","text":"Introduction to ROS \u00b6 ROS is an open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For Race On, however, we will focus mostly on the use of packages and message types . The power of ROS comes from the use of a computation graph similar to one used by Tensorflow, a machine learning library. The computation graph is composed from a number of nodes which either produce or consume data from multiple sources through a publish/subscribe architecture. At initialization, nodes declaretheir name and subscribe to the topics which provide all the necessary information for the node to properly function. Each topic has an associated message type which defines the format that the publishers and subscribers will use to exchange information. Some nodes might only publish data, such as the camera node, some might only subscribe to data topics, such as the motor and servo node, and some might do both such as the image processing node that receives images and outputs the car track position. ROS concepts review. Packages - In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together. Message Types - Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in the `msg folder of your package. For more info about defining a custom message type in ROS, check out creating a ROS msg and srv . Nodes - Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for Race On, we are using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics . Topics - Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. Messages - Messages are simple data structures that can contain a combination of basic data types. For a more in depth discussion of common ROS concepts, check out ROS concepts . Preparation \u00b6 Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congratulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot ROS Tutorial \u00b6 Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. If you're looking for more, here's another tutorial which provides information on creating a package in a catkin workspace . To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions how to build the C++ code, and the src is the directory where you place all your source files. To change the dependency list of your package at a later time or customize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface, navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. First line tells the terminal that this is a Python script. All Python files should have it. The next three lines import the Python libraries which we declared as dependencies for the tutorial package and the math library required for the to calculate the sinusoid values. Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interfaces with the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master . In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for the subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Remember to make the subscriber script executable. Exerices To better understan ROS concepts try to improve the above code by adding the following two features: 1. Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration 1. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application. Setting Up ROS for Your Car \u00b6 To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 . Overview of Race On ROS Code \u00b6 The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them. Launch File \u00b6 The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file. Exercise \u00b6 Read through the launch file to get a better understanding of how it works. Change or remove the parameters defined in it to see how the nodes respond. Camera Node \u00b6 Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory. Suggested Exercise \u00b6 Try adjusting the frame rate from the launch file and see how it affects your car's trajectory! Position Estimation Node \u00b6 Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic . Suggested Exercise \u00b6 Try changing the peak threshold and see how it affects your estimation of the track and car positions! Controller Node \u00b6 Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic . Suggested Exercises \u00b6 Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior. Actuator Node \u00b6 Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed. Car Module \u00b6 The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car.","title":"1. Introduction to ROS"},{"location":"Workshops/ros/#introduction-to-ros","text":"ROS is an open-source framework that aims to simplify the complexities involved in writing robust, general robotics software. ROS has a number of important filesystem level concepts, including packages, metapackages, package manifests, repositories, message types and service types. For Race On, however, we will focus mostly on the use of packages and message types . The power of ROS comes from the use of a computation graph similar to one used by Tensorflow, a machine learning library. The computation graph is composed from a number of nodes which either produce or consume data from multiple sources through a publish/subscribe architecture. At initialization, nodes declaretheir name and subscribe to the topics which provide all the necessary information for the node to properly function. Each topic has an associated message type which defines the format that the publishers and subscribers will use to exchange information. Some nodes might only publish data, such as the camera node, some might only subscribe to data topics, such as the motor and servo node, and some might do both such as the image processing node that receives images and outputs the car track position. ROS concepts review. Packages - In ROS, packages are the primary means of organizing software and are the smallest item you can build and release. They can contain any collection of files that should logically be contained together. Message Types - Message types describe message data structures and outline which data types they contain. When creating a message type, they should be contained in the `msg folder of your package. For more info about defining a custom message type in ROS, check out creating a ROS msg and srv . Nodes - Nodes are modular processes that perform some computation for your system. They should be a logical unit within your sytem. For example, for Race On, we are using 4 nodes (actuation.py, camera.py, control.py and pos_estimation.py), all of which handle a specific part of the car's behavior. Each of these nodes communicate by publishing and subscribing to messages on different topics . Topics - Nodes can send out and receive messages by publishing and subscribing to topics . Each topic has a name, which should be associated with the message types or message content being sent through it. For example, the control node in the race-on-ros repository subscribes to Pose messages on the position/error topic and publishes AckermanDrive messages on the control topic. Note that you can only send one message type through a single topic. Messages - Messages are simple data structures that can contain a combination of basic data types. For a more in depth discussion of common ROS concepts, check out ROS concepts .","title":"Introduction to ROS"},{"location":"Workshops/ros/#preparation","text":"Before we proceed with this quickstart quide we need to perform a few preparation steps. If you plan to perform these steps using a Jupyter terminal instead of ssh, please before starting close all Jupyter tabs except the terminal. Update the list of packages and install all the available software updates. 1 2 sudo apt update sudo apt upgrade Install the OpenCV library for Python3. We will use the OpenCV functions for camera calibration and image preprocessing. 1 sudo apt install python3-opencv Instruct ROS to use Python 3 by setting the ROS_PYTHON_VERSION environment variable. 1 echo \"export ROS_PYTHON_VERSION=3\" >> ~/.bashrc The .bashrc file in the home folder contains all the commands which are executed when you open a terminal. The startup folder in the home directory contains the scripts which are run everytime the Pi boots to setup the hardware and start the Jupyter and the ROS services. We need to modify the ROS script to allow the external devices connect to the ROS running on the Pi. For that open the file ~/startup/ros.sh using the Jupyter interface and, if present, remove the line export ROS_HOSTNAME=raspberrypi\" . In addition, since these scripts are crucial for the Race On platform to function properly we will make them read only to prevent accedental edits. For that run the following command in the terminal. 1 chmod a-w ~/startup/* where the argument a stands for all, - remove, and w write permission. Now we can prepare the ROS workspace. The race-on-ros folder contains the GitHub repository of the Race On team and only Race On organizers can push updates back to GitHub. To solve this issue we need to first delete the folder, fork the GitHub repository using your own GitHub account where you can add collaborators, and then clone back on Pi the forked repository. To delete the folder, run 1 rm -rf ~/race-on-ros Next, go to the GitHub page of the race-on-ros repository and click the fork button on the upper left corner. After a few seconds you should be redirected to your own race-on-ros repository. Clone the forked repository using the following command 1 git clone https://github.com/<your-username>/race-on-ros.git Now you should see again the race-on-ros folder in your home directory but this time the repository is linked to your own GitHub account. Before we can use the raceon package we need to build it since only source files are commited to GitHub. The following two commands are crucial and if you later experience problems with the ROS code then most likely you forgot to run them. You need to run these commands every time you add new files or dependencies to your packages so ROS knows about them. 1 2 catkin_make -C ~/race-on-ros/ source ~/race-on-ros/devel/setup.bash First line compiles all the packages in the workspace whereas the second command lets ROS know about the new compiled files. Moreover, the catkin_make command should also create two additional folders in the workspace, build and devel . The build folder is the default location of the build space and is where cmake and make are called to configure and build your packages. The devel folder is the default location of the devel space, which is where your executables and libraries go before you install your packages. Congratulations, you successfully completed all the steps required to setup the Race On ROS environment. But before proceeding with the next section reboot to apply the updates. 1 sudo reboot","title":"Preparation"},{"location":"Workshops/ros/#ros-tutorial","text":"Before we introduce the Race On code for ROS we will do a quick tutorial. In ROS, code is organized around packages which are folders with special structure inside the src folder of the workspace. If you run ls ~/race-on-ros/src you will see that the race-on-ros workspace contains only the raceon package. In this tutorial we will create a new package called tutorial that will have two nodes, the publisher node that publishes a sequence of numbers to the data topic and the subscriber node that will subscribe to the data topic to receive the sequence. If you're looking for more, here's another tutorial which provides information on creating a package in a catkin workspace . To create a new package we have first to make ~/race-on-ros/src the current directory and then run the ROS catkin_create_pkg to create a package folder. 1 2 cd ~/race-on-ros/src catkin_create_pkg tutorial std_msgs rospy The arguments for the catkin_create_pkg command are the package name followed by the dependencies of the new package. In this case, the dependencies are std_msgs and rospy . Since we will send Float32 numbers we will use std_msgs as it includes common message types representing primitive data types and other basic message constructs. And rospy since we will write our code in Python. If you plan to write code in C or C++ you must also add roscpp to the dependency list. In case you forget to add a package as dependence, you can do that later by editing one of the package configuration files. To check the result of the command we can list the contents of the tutorial folder using ls -ahl tutorial/ and you should see an output similar to this: 1 2 3 4 5 6 total 24K drwxr-xr-x 3 pi pi 4 .0K Feb 15 03 :06 . drwxr-xr-x 4 pi pi 4 .0K Feb 15 03 :06 .. -rw-r--r-- 1 pi pi 6 .9K Feb 15 03 :06 CMakeLists.txt -rw-r--r-- 1 pi pi 2 .7K Feb 15 03 :06 package.xml drwxr-xr-x 2 pi pi 4 .0K Feb 15 03 :06 src Where package.xml contains the package configuration in XML format, CMakeLists.txt contains the instructions how to build the C++ code, and the src is the directory where you place all your source files. To change the dependency list of your package at a later time or customize the package, edit the package.xml file. However, since our code will be only written in Python, we will create a separate folder called scripts to place our Python programs using the mkdir tutorial/scripts command. To build the package run 1 2 cd ~/race-on-ros/ catkin_make Since we did not write any code this will should not encounter any errors, just see that catkin , the build tool of ROS, recognized the new package and traversed it contents. Create the publisher node. In ROS, a \"node\" is an executable that is connected to the ROS network. Here we will create the publisher node which will continuously send samples generated using a sinusoidal signal. Using the Jupyter interface, navigate to the race-on-ros/src/tutorial/scripts/ folder and create a new text file called publisher.py . Paste this content inside the file and save it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 import math RATE = 10 # Publishing rate of new data per second FREQ = 1 # Frequency of the sinusoidal signal # Execute this when run as a script if __name__ == '__main__' : rospy . init_node ( 'publisher' ) pub = rospy . Publisher ( 'data' , Float32 , queue_size = 1 ) rate = rospy . Rate ( RATE ) step = 0 while not rospy . is_shutdown (): # Generate new data point value = math . sin ( 2 * math . pi * step / RATE ) # Log and publish data rospy . loginfo ( \"Publishing {:.3f} \" . format ( value )) pub . publish ( value ) # Advance the sequence step = step + 1 # Wait to match the rate rate . sleep () The break down. First line tells the terminal that this is a Python script. All Python files should have it. The next three lines import the Python libraries which we declared as dependencies for the tutorial package and the math library required for the to calculate the sinusoid values. Next, we declare two global constants which are parameters of the generated sequence. The code inside the if statement represents the main program. Here we define how the publisher node interfaces with the rest of ROS. The line rospy.init_node(NAME) , is very important as it tells rospy the name of the node -- until rospy has this information, it cannot start communicating with the ROS Master . In this case, the node will take on the name publisher . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". The rospy.Publisher('data', Float32, queue_size=1) declares that your node is publishing to the data topic using the message type Float32 . Float32 here is actually the class std_msgs.msg.Float32. The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. rate = rospy.Rate(RATE) this line creates a Rate object rate. With the help of its method sleep(), it offers a convenient way for looping at the desired rate. With its argument of 10, we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10 th of a second!). Next we have a fairly standard rospy loop construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(value) that publishes a string to our data topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. To run the code we need first to make the script executable by changing the file permission using chmod +x ~/race-on-ros/src/tutorial/scripts/publisher.py command. Now, we can run the code using rosrun tutorial publisher.py command. Note, tab autocompletion works with ROS command arguments. The code for the subscriber is similar and the steps are the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python import rospy from std_msgs.msg import Float32 # Automatically called by ROS when new message is received def callback ( message ): rospy . loginfo ( \"Received {:.3f} \" . format ( message . data )) # Execute this when run as a script if __name__ == '__main__' : # Init the node and subscribe for data rospy . init_node ( \"subscriber\" ) rospy . Subscriber ( \"data\" , Float32 , callback ) # Prevents python from exiting until this node is stopped rospy . spin () Now you can open a second terminal to run the subscriber. Remember to make the subscriber script executable. Exerices To better understan ROS concepts try to improve the above code by adding the following two features: 1. Create a launch file to start both nodes at the same time. Consult ROS documentation and raceon package code for inspiration 1. Replace the global constants in the publisher.py file with ROS parameters. Update the launch file to include the default parameter values. Find how to overwrite the parameter value when you launch the application.","title":"ROS Tutorial"},{"location":"Workshops/ros/#setting-up-ros-for-your-car","text":"To run the ros nodes, run roslaunch raceon raceon.launch speed:=140 .","title":"Setting Up ROS for Your Car"},{"location":"Workshops/ros/#overview-of-race-on-ros-code","text":"The ROS repository for Race On consists of 4 ROS nodes and one Python class that initializes the car configuration (including the servo's middle and rightmost values and the motor's min, max and brake speeds) and provides functions for steering and changing the speed of the car. The 4 nodes included in the repository are actuation.py, camera.py, control.py and pos_estimation.py. The nodes should be run using the file race-on-ros/src/launch/raceon.launch . Read more below to learn more about each of the nodes and the launch file we've provided to run them.","title":"Overview of Race On ROS Code"},{"location":"Workshops/ros/#launch-file","text":"The launch file has a number of parameters for each of the nodes, which you can customize according to your needs. It also defines the topics to which the nodes publish and subscribe. For example, the camera node publishes to either camera/image or camera/image/compressed topic, depending on the value of the ~publish_raw parameter, which is defined below on line 13 of the launch file.","title":"Launch File"},{"location":"Workshops/ros/#exercise","text":"Read through the launch file to get a better understanding of how it works. Change or remove the parameters defined in it to see how the nodes respond.","title":"Exercise"},{"location":"Workshops/ros/#camera-node","text":"Topics Message Type Action camera/image Image Publish camera/image/compressed CompressedImage Publish The camera node, which is found in race-on-ros/src/scripts/camera.py starts up the pi's camera and begins recording upon startup. Depending on the value of the ~use_compressed_image parameter, it will either publish compressed images on the camera/image/compressed or uncompressed images on the camera/image topic. The resolution , frames per second and publish_raw parameters can be configured in the launch file.","title":"Camera Node"},{"location":"Workshops/ros/#suggested-exercise","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory.","title":"Suggested Exercise"},{"location":"Workshops/ros/#suggested-exercise_1","text":"Try adjusting the frame rate from the launch file and see how it affects your car's trajectory!","title":"Suggested Exercise"},{"location":"Workshops/ros/#position-estimation-node","text":"Topics Message Type Action camera/image Image Subscribe camera/image/compressed CompressedImage Subscribe position/error Pose Publish `position/track TrackPosition Publish The position estimation node is found in race-on-ros/src/scripts/pos_estimation.py . This node executes much of the position-estimation functionality you likely saw before in the testcar-nomiddleline jupyter notebook . Depending on the value of the use_compressed_image parameter, the camera node will either subscribe to the camera/image/compressed or camera/image topic. You can set the scan line , peak threshold , track width and camera center parameters in the launch file or adjust their default values in the node's code. The scan line parameter is the horizontal line in the image that you'll use to look for peaks. When the node receives an image message, it finds peaks along the horizontal scan line and uses them to estimate the car's position within the track. It then publishes this position estimation to the \"position/error\" topic . It also publishes an estimation of the track position to the \"position/track\" topic .","title":"Position Estimation Node"},{"location":"Workshops/ros/#suggested-exercise_2","text":"Try changing the peak threshold and see how it affects your estimation of the track and car positions!","title":"Suggested Exercise"},{"location":"Workshops/ros/#controller-node","text":"Topics Message Type Action position/error Pose Subscribe control AckermanDrive Publish The controller node is found in race-on-ros/src/scripts/controller.py . The control node is where you'll want to put your team's control logic (potentially a PID controller?). Currently, the control node uses a proportional gain coefficient to determine how much you should alter the servo's position to minimize the distance from the target position. You can change the motor speed , target (target x position on the track) and kp (proportional gain coefficient to use to scale the error) parameters in the launch file or alter their default values in the code. When the controller node receives a Pose message containing the car's current position on the track, it calculates the error from the target position and estimates a new servo position value using kp to steer the car closer to the target. It then publishes this new servo position and the current motor speed to the control topic .","title":"Controller Node"},{"location":"Workshops/ros/#suggested-exercises","text":"Adjust the motor speed and proportional gain parameters and see how they alter your car's behavior.","title":"Suggested Exercises"},{"location":"Workshops/ros/#actuator-node","text":"Topics Message Type Action control AckermanDrive Subscribe The actuator node is found in race-on-ros/src/scripts/actuation.py . It subscribes to the control topic and is responsible for commanding the car . To do so, it makes use of the car module, which has utility functions to set the car's speed and servo position. When the actuator node receives a control message, it uses the car module functions to steer the car and set its speed.","title":"Actuator Node"},{"location":"Workshops/ros/#car-module","text":"The car module is a class that initializes the servo and motor and provides functions to alter the car's speed and the servo's position and also to brake the car.","title":"Car Module"}]}